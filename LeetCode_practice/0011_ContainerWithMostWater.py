# _*_coding:utf-8_*_
'''
11 盛最多水的容器
题目：
    给你 n 个非负整数 a1, a2, a3...an，每个数代表坐标中的一个点 (i, ai)
    在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为（i, ai)和（i, 0)
    找出其中的两条线，使得他们与 x 轴共同构成的容易可以容纳最多的水

    说明：你不能倾斜容器，且 n 的值至少为 2

示例：
    输入：[1,8,6,2,5,4,8,3,7]
    输出：49
'''

from typing import List


class Solution:
    def maxArea(self, height: List[int]) -> int:
        '''
        思路：算法流程：设置双指针 i，j 分别位于容器壁两侧，根据规则移动指针
                       并且更新面积最大值res，直到i==j时返回res
             指针移动规则与证明：每次选定围成水槽两板高度 h[i] h[j]中的短板，
                    向中间收窄1格，以下证明：
                    1，设置每一状态下水槽面积为S(i, j) (0<=i<j<n),由于水槽的实际
                    高度由两板中的短板决定，则可得面积公式S(i, j)=min(h[i], h[j])*(j-i)S(i, j)
                                                        =min(h[i], h[j])(j-i)
                    2，在每一个状态下，无论长板或者短板收窄1格，都会导致水槽，低边宽度-1
                        若向内移动短板，水槽的短边min(h[i], h[j])可能变大，因此水槽面积S(i, j)可能增大
                        若向内移动长板，水槽的短板min(h[i], h[j])不变或变小，下个水槽的面积一定小于当前水槽面积
            因此，向内收窄短板可以获取面积最大值，换个角度理解
                若不指定移动规则，所有移动出现的S(i, j)的状态数为C(n, 2)，即暴力枚举出所有状态
                在状态S(i, j)下向内移动短板至S(i+1, j)（假设h[i]<h[j])，则相当于消去了s(i, j-1) s(i, j-2),...s(i, j+1)
                状态集合，而所有消去状态的面积一定 <= S(i, j)
                    短板高度：相比S(i, j)相同或者更短，（<=h[i]）
                    底边宽度：相比S(i, j)更短
                因此所有消去的状态的面积都 < S(i, j) ，通俗的说，我们每次向内移动短板，所有的消去状态都不会
                导致丢失面积最大值

        时间复杂度O(N)，双指针遍历一次底边宽度N
        空间复杂度O(1) 指针使用常数额外空间
        :param height:
        :return:
        '''
        pass


def maxArea1(height):
    '''
    求解容纳最多的水，也就是面积最大，面积等于长乘以宽
    长：两个坐标点之间的距离，即下标之差
    宽：即下标所对应的值
    就是上面的思路：首先取一个变量保存面积最大值（常数额外空间）然后从左右遍历
    两个指针，找到面积最大的一个

    :param height:
    :return:
    '''
    i, j, res = 0, len(height) - 1, 0
    while i < j:
        if height[i] < height[j]:
            res = max(res, height[i] * (j - i))
            i += 1
        else:
            res = max(res, height[j] * (j - i))
            j -= 1
    return res


height = [1, 8, 6, 2, 5, 4, 8, 3, 7]  # 49
res = maxArea1(height)
print(res)
